<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Reflections - Luke R. Young</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Lora:ital@0;1&display=swap">
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.4/dist/gsap.min.js"></script>
    <style>
        /* General font styles */
        body {
            font-family: 'Lora', serif;
            color: #e8f5e9;
            margin: 0;
            overflow-x: hidden;
            background-color: #0a2815;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Playfair Display', serif;
        }

        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .overlay {
            background: rgba(10, 40, 21, 0.6);
            position: relative;
            z-index: 1;
        }
        
        .blog-post {
            border-left: 4px solid #66bb6a;
            transition: all 0.3s ease;
            background: rgba(26, 51, 30, 0.85);
            backdrop-filter: blur(8px);
        }
        
        .blog-post:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 90, 50, 0.3);
        }
        
        .date {
            color: #81c784;
            font-style: italic;
        }

        .forest-gradient {
            background: linear-gradient(135deg, #2e7d32, #66bb6a);
        }
        
        #password-form {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
            z-index: 10;
        }

        #content {
            display: none;
        }
        
        .elegant-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 60, 30, 0.3), 0 4px 6px -2px rgba(0, 60, 30, 0.2);
        }
        
        .quote {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            position: relative;
        }
        
        .quote:before {
            content: """;
            font-size: 2rem;
            position: absolute;
            left: -1rem;
            top: -0.5rem;
            color: #66bb6a;
            opacity: 0.8;
        }
        
        .quote:after {
            content: """;
            font-size: 2rem;
            position: absolute;
            right: -1rem;
            bottom: -1.5rem;
            color: #66bb6a;
            opacity: 0.8;
        }

        .header-content {
            position: relative;
            z-index: 2;
            background: rgba(26, 51, 30, 0.75);
            backdrop-filter: blur(8px);
            border-radius: 0.5rem;
            padding: 2rem;
        }

        .glass-card {
            background: rgba(26, 51, 30, 0.75);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 1px solid rgba(102, 187, 106, 0.2);
            transition: all 0.3s ease;
        }

        .glass-card:hover {
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(-5px);
        }

        .parallax-section {
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Input fields & button overrides */
        input, textarea {
            background-color: rgba(20, 40, 25, 0.8) !important;
            color: #e8f5e9 !important;
            border-color: #66bb6a !important;
        }
        
        input::placeholder, textarea::placeholder {
            color: #a5d6a7 !important;
            opacity: 0.7;
        }
        
        input:focus, textarea:focus {
            outline-color: #66bb6a !important;
            box-shadow: 0 0 0 3px rgba(102, 187, 106, 0.3) !important;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <div id="password-form" class="max-w-md mx-auto p-8 rounded-lg">
        <div class="glass-card p-8 rounded-lg">
            <h2 class="text-3xl font-bold mb-6 text-center text-green-100">Forest Reflections</h2>
            <p class="mb-4 text-center text-green-200">Enter the password to access this personal blog</p>
            <div class="space-y-4 w-full">
                <input type="password" id="password-input" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-green-400" placeholder="Enter password">
                <button id="submit-btn" class="w-full forest-gradient hover:opacity-90 text-white font-bold py-2 px-4 rounded-md transition-colors">Enter</button>
            </div>
            <p id="error-message" class="text-red-500 mt-4 text-center hidden">Incorrect password. Please try again.</p>
        </div>
    </div>

    <div id="content">
        <header class="py-16 relative">
            <div class="max-w-5xl mx-auto px-6">
                <div class="header-content">
                    <div class="flex justify-between items-center mb-4">
                        <h1 class="text-4xl md:text-5xl font-bold text-green-100 animate-header">Forest Reflections</h1>
                        <a href="index.html" class="text-green-400 hover:text-green-300 font-semibold">‚Üê Home</a>
                    </div>
                    <p class="text-xl text-green-200 italic">A collection of quotes and personal reflections</p>
                </div>
            </div>
        </header>
        
        <main class="max-w-3xl mx-auto py-12 px-6 relative z-10">
            <!-- Blog Controls -->
            <div class="flex justify-between items-center mb-8">
                <h2 class="text-2xl font-bold">My Thoughts</h2>
                <button id="new-post-btn" class="forest-gradient text-white px-4 py-2 rounded-md hover:opacity-90 transition-opacity">
                    New Entry
                </button>
            </div>

            <!-- New Post Form -->
            <div id="post-form" class="mb-12 glass-card p-6 rounded-lg hidden">
                <div class="mb-4">
                    <label for="post-title" class="block mb-2 font-semibold">Title</label>
                    <input type="text" id="post-title" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-green-400">
                </div>
                <div class="mb-4">
                    <label for="post-content" class="block mb-2 font-semibold">Content</label>
                    <textarea id="post-content" rows="8" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-green-400"></textarea>
                </div>
                <div class="flex space-x-2 justify-end">
                    <button id="cancel-post" class="px-4 py-2 border rounded-md hover:bg-gray-700 text-green-200 border-green-600 transition-colors">Cancel</button>
                    <button id="save-post" class="forest-gradient text-white px-4 py-2 rounded-md hover:opacity-90 transition-opacity">Save</button>
                </div>
                <input type="hidden" id="post-id" value="">
            </div>

            <!-- Post container -->
            <div id="posts-container" class="space-y-8">
                <!-- Blog posts will be loaded here dynamically -->
                <div class="text-center py-12" id="loading-posts">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500"></div>
                    <p class="mt-2 text-gray-400">Loading your thoughts...</p>
                </div>
                <div class="hidden text-center py-12" id="no-posts">
                    <p class="text-gray-400">No thoughts yet. Click "New Entry" to add one.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Three.js Realistic Grass Animation
        let scene, camera, renderer;
        let grassField, skyMesh;
        let clock = new THREE.Clock();
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a2815, 0.005);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 100);
            camera.lookAt(0, 20, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('three-canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a2815, 1);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x3f5c34, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffbe54, 1.5);
            sunLight.position.set(-100, 50, -100);
            scene.add(sunLight);
            
            // Sunset Sky
            createSunsetSky();
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(400, 400);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a3a1a,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            scene.add(ground);
            
            // Create grass field
            createGrassField();
            
            // Event listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
        }
        
        function createSunsetSky() {
            // Create a large sphere to simulate sky
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            
            // Create gradient for sunset
            const uniforms = {
                topColor: { value: new THREE.Color(0x0a2815) },      // Dark green at top
                bottomColor: { value: new THREE.Color(0xffa343) },   // Orange at horizon (sunset)
                offset: { value: 50 },
                exponent: { value: 0.6 }
            };
            
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(h, exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            skyMesh = new THREE.Mesh(skyGeo, skyMaterial);
            scene.add(skyMesh);
        }
        
        function createGrassField() {
            // Create instanced grass blades
            const instanceCount = 10000; // Number of grass blades
            const grassWidth = 1.0;
            const grassHeight = 5.0;
            
            // Create blade geometry
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(grassWidth / 2, 0);
            bladeShape.quadraticCurveTo(0, grassHeight / 4, 0, grassHeight);
            bladeShape.quadraticCurveTo(0, grassHeight / 4, -grassWidth / 2, 0);
            bladeShape.lineTo(0, 0);
            
            const extrudeSettings = {
                steps: 1,
                depth: 0.05,
                bevelEnabled: false
            };
            
            const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, extrudeSettings);
            bladeGeometry.rotateX(-Math.PI / 2);
            
            // Instanced grass material with gradient
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a803b,
                roughness: 0.8,
                vertexColors: true
            });
            
            // Add vertex colors for gradient effect
            const positions = bladeGeometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);
            
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i) + grassHeight / 2;
                const gradient = Math.max(0.4, Math.min(y / grassHeight, 1.0));
                
                // Dark green at bottom, lighter at top
                const darkGreen = new THREE.Color(0x1a553a);
                const lightGreen = new THREE.Color(0x4aba5f);
                const color = new THREE.Color().lerpColors(darkGreen, lightGreen, gradient);
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            bladeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create instanced mesh
            grassField = new THREE.InstancedMesh(bladeGeometry, grassMaterial, instanceCount);
            
            // Matrix for each instance
            const dummy = new THREE.Object3D();
            const areaSize = 200; // Size of the field
            
            for (let i = 0; i < instanceCount; i++) {
                // Random position
                const x = (Math.random() - 0.5) * areaSize;
                const z = (Math.random() - 0.5) * areaSize;
                const y = 0;
                
                // Random scale
                const scale = 0.6 + Math.random() * 0.8;
                
                // Random rotation
                const rotY = Math.random() * Math.PI * 2;
                
                // Apply transformations
                dummy.position.set(x, y, z);
                dummy.rotation.set(0, rotY, 0);
                dummy.scale.set(scale, scale + Math.random() * 0.3, scale);
                dummy.updateMatrix();
                
                grassField.setMatrixAt(i, dummy.matrix);
            }
            
            scene.add(grassField);
        }
        
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - windowHalfX) * 0.01;
            mouseY = (event.clientY - windowHalfY) * 0.01;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // Sway the grass
            if (grassField) {
                const dummy = new THREE.Object3D();
                
                for (let i = 0; i < grassField.count; i++) {
                    grassField.getMatrixAt(i, dummy.matrix);
                    dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                    
                    // Calculate sway based on position (so adjacent blades sway together)
                    const swayX = Math.sin(time * 1.5 + dummy.position.x * 0.05) * 0.1;
                    const swayZ = Math.cos(time * 1.2 + dummy.position.z * 0.05) * 0.05;
                    
                    // Apply rotation to simulate wind
                    dummy.rotation.x = swayX;
                    dummy.rotation.z = swayZ;
                    
                    dummy.updateMatrix();
                    grassField.setMatrixAt(i, dummy.matrix);
                }
                
                grassField.instanceMatrix.needsUpdate = true;
            }
            
            // Move camera based on mouse position
            camera.position.x += (mouseX - camera.position.x) * 0.01;
            camera.position.y += (-mouseY + 20 - camera.position.y) * 0.01;
            camera.lookAt(0, 15, 0);
            
            renderer.render(scene, camera);
        }

        // Parallax effect for blog posts
        function handleParallax() {
            const parallaxElements = document.querySelectorAll('.parallax-section');
            
            window.addEventListener('scroll', function() {
                const scrollY = window.scrollY;
                
                parallaxElements.forEach(element => {
                    const speed = parseFloat(element.getAttribute('data-speed'));
                    const yOffset = scrollY * speed;
                    element.style.transform = `translateY(${yOffset}px)`;
                });
            });
        }
        
        // Blog Database Management
        class BlogDB {
            constructor() {
                this.dbName = 'sunlitThoughtsDB';
                this.dbVersion = 1;
                this.storeName = 'posts';
                this.db = null;
                this.init();
            }
            
            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = event => {
                        console.error('Database error:', event.target.error);
                        reject('Could not open database');
                    };
                    
                    request.onsuccess = event => {
                        this.db = event.target.result;
                        console.log('Database opened successfully');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = event => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                            store.createIndex('title', 'title', { unique: false });
                            store.createIndex('date', 'date', { unique: false });
                            console.log('Object store created');
                        }
                    };
                });
            }
            
            async getAllPosts() {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        resolve(request.result.sort((a, b) => new Date(b.date) - new Date(a.date)));
                    };
                    
                    request.onerror = event => {
                        console.error('Error fetching posts:', event.target.error);
                        reject('Failed to fetch posts');
                    };
                });
            }
            
            async addPost(post) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.add(post);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error adding post:', event.target.error);
                        reject('Failed to add post');
                    };
                });
            }
            
            async updatePost(post) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.put(post);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error updating post:', event.target.error);
                        reject('Failed to update post');
                    };
                });
            }
            
            async deletePost(id) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(id);
                    
                    request.onsuccess = () => {
                        resolve();
                    };
                    
                    request.onerror = event => {
                        console.error('Error deleting post:', event.target.error);
                        reject('Failed to delete post');
                    };
                });
            }
            
            async getPost(id) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(id);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error fetching post:', event.target.error);
                        reject('Failed to fetch post');
                    };
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Three.js
            init();
            
            // Database instance
            const blogDB = new BlogDB();
            
            // UI Elements
            const submitBtn = document.getElementById('submit-btn');
            const passwordInput = document.getElementById('password-input');
            const passwordForm = document.getElementById('password-form');
            const content = document.getElementById('content');
            const errorMessage = document.getElementById('error-message');
            const newPostBtn = document.getElementById('new-post-btn');
            const postForm = document.getElementById('post-form');
            const postsContainer = document.getElementById('posts-container');
            const loadingElement = document.getElementById('loading-posts');
            const noPostsElement = document.getElementById('no-posts');
            const postTitleInput = document.getElementById('post-title');
            const postContentInput = document.getElementById('post-content');
            const postIdInput = document.getElementById('post-id');
            const savePostBtn = document.getElementById('save-post');
            const cancelPostBtn = document.getElementById('cancel-post');
            
            // The password to access the content
            const correctPassword = "08151769";
            
            // Check if already authenticated
            const isAuthenticated = sessionStorage.getItem('privateAuth');
            if (isAuthenticated === 'true') {
                showContent();
            }
            
            // Event Listeners
            submitBtn.addEventListener('click', validatePassword);
            passwordInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') {
                    validatePassword();
                }
            });
            
            newPostBtn.addEventListener('click', () => {
                resetForm();
                postForm.classList.remove('hidden');
            });
            
            cancelPostBtn.addEventListener('click', () => {
                postForm.classList.add('hidden');
            });
            
            savePostBtn.addEventListener('click', handleSavePost);
            
            // Functions
            function validatePassword() {
                if (passwordInput.value === correctPassword) {
                    sessionStorage.setItem('privateAuth', 'true');
                    showContent();
                } else {
                    errorMessage.classList.remove('hidden');
                    passwordInput.value = '';
                }
            }
            
            function showContent() {
                passwordForm.style.display = 'none';
                content.style.display = 'block';
                
                // Initialize parallax after content is shown
                handleParallax();
                
                // Load blog posts
                loadPosts();
                
                // Animation for header
                gsap.from('.animate-header', {
                    opacity: 0,
                    y: 30,
                    duration: 1,
                    ease: "power2.out"
                });
            }
            
            async function loadPosts() {
                try {
                    const posts = await blogDB.getAllPosts();
                    displayPosts(posts);
                } catch (error) {
                    console.error('Error loading posts:', error);
                    alert('Failed to load posts. Please try again.');
                } finally {
                    loadingElement.classList.add('hidden');
                }
            }
            
            function displayPosts(posts) {
                // Clear previous posts
                const postsOnly = Array.from(postsContainer.children).filter(child => 
                    child.id !== 'loading-posts' && child.id !== 'no-posts'
                );
                postsOnly.forEach(post => post.remove());
                
                if (posts.length === 0) {
                    noPostsElement.classList.remove('hidden');
                    return;
                }
                
                noPostsElement.classList.add('hidden');
                
                // Create and append posts
                posts.forEach((post, index) => {
                    const postElement = createPostElement(post, index);
                    postsContainer.appendChild(postElement);
                });
                
                // Apply parallax to new elements
                handleParallax();
                
                // Animate posts
                gsap.from('.blog-post', {
                    opacity: 0,
                    y: 50,
                    stagger: 0.2,
                    duration: 0.8,
                    ease: "back.out(1.7)"
                });
            }
            
            function createPostElement(post, index) {
                const article = document.createElement('article');
                article.className = `blog-post pl-6 pt-2 pb-6 rounded-lg elegant-shadow parallax-section`;
                article.dataset.speed = 0.03 + (index * 0.02);
                article.dataset.id = post.id;
                
                const formattedDate = new Date(post.date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                article.innerHTML = `
                    <div class="flex justify-between items-start">
                        <p class="date text-sm mb-3">${formattedDate}</p>
                        <div class="flex space-x-2">
                            <button class="edit-post-btn text-green-300 hover:text-green-100">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                </svg>
                            </button>
                            <button class="delete-post-btn text-red-400 hover:text-red-300">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <h2 class="text-2xl font-bold mb-4 text-green-100">${post.title}</h2>
                    <div class="prose prose-invert prose-green">
                        <p class="mb-4 text-green-200">${post.content.replace(/\n/g, '<br>')}</p>
                    </div>
                `;
                
                // Add event listeners
                article.querySelector('.edit-post-btn').addEventListener('click', () => {
                    editPost(post.id);
                });
                
                article.querySelector('.delete-post-btn').addEventListener('click', () => {
                    deletePost(post.id);
                });
                
                return article;
            }
            
            async function handleSavePost() {
                const title = postTitleInput.value.trim();
                const content = postContentInput.value.trim();
                const id = postIdInput.value ? parseInt(postIdInput.value) : null;
                
                if (!title || !content) {
                    alert('Please fill in both title and content');
                    return;
                }
                
                try {
                    if (id) {
                        // Update existing post
                        const post = await blogDB.getPost(id);
                        post.title = title;
                        post.content = content;
                        post.updated = new Date().toISOString();
                        await blogDB.updatePost(post);
                    } else {
                        // Add new post
                        const post = {
                            title,
                            content,
                            date: new Date().toISOString(),
                            updated: null
                        };
                        await blogDB.addPost(post);
                    }
                    
                    postForm.classList.add('hidden');
                    resetForm();
                    loadPosts();
                } catch (error) {
                    console.error('Error saving post:', error);
                    alert('Failed to save post. Please try again.');
                }
            }
            
            async function editPost(id) {
                try {
                    const post = await blogDB.getPost(id);
                    postTitleInput.value = post.title;
                    postContentInput.value = post.content;
                    postIdInput.value = post.id;
                    postForm.classList.remove('hidden');
                    postForm.scrollIntoView({ behavior: 'smooth' });
                } catch (error) {
                    console.error('Error editing post:', error);
                    alert('Failed to edit post. Please try again.');
                }
            }
            
            async function deletePost(id) {
                if (!confirm('Are you sure you want to delete this post?')) {
                    return;
                }
                
                try {
                    await blogDB.deletePost(id);
                    loadPosts();
                } catch (error) {
                    console.error('Error deleting post:', error);
                    alert('Failed to delete post. Please try again.');
                }
            }
            
            function resetForm() {
                postTitleInput.value = '';
                postContentInput.value = '';
                postIdInput.value = '';
            }
        });
    </script>
</body>
</html>
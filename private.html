<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stormy Reflections - Luke R. Young</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,600;1,400&family=Crimson+Pro:wght@300;400;600&display=swap">
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.4/dist/gsap.min.js"></script>
    <style>
        /* General font styles */
        body {
            font-family: 'Crimson Pro', serif;
            color: #e1e7f0;
            margin: 0;
            overflow-x: hidden;
            background-color: #0f172a;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'EB Garamond', serif;
        }

        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .overlay {
            background: rgba(15, 23, 42, 0.6);
            position: relative;
            z-index: 1;
        }
        
        .blog-post {
            border-left: 4px solid #64748b;
            transition: all 0.3s ease;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(8px);
        }
        
        .blog-post:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(15, 23, 42, 0.5);
        }
        
        .date {
            color: #94a3b8;
            font-style: italic;
        }

        .ocean-gradient {
            background: linear-gradient(135deg, #1e3a8a, #3b82f6);
        }
        
        #password-form {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
            z-index: 10;
        }

        #content {
            display: none;
        }
        
        .elegant-shadow {
            box-shadow: 0 10px 15px -3px rgba(15, 23, 42, 0.3), 0 4px 6px -2px rgba(30, 41, 59, 0.2);
        }
        
        .quote {
            font-family: 'EB Garamond', serif;
            font-style: italic;
            position: relative;
        }
        
        .quote:before {
            content: """;
            font-size: 2rem;
            position: absolute;
            left: -1rem;
            top: -0.5rem;
            color: #60a5fa;
            opacity: 0.8;
        }
        
        .quote:after {
            content: """;
            font-size: 2rem;
            position: absolute;
            right: -1rem;
            bottom: -1.5rem;
            color: #60a5fa;
            opacity: 0.8;
        }

        .header-content {
            position: relative;
            z-index: 2;
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border-radius: 0;
            padding: 2rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .glass-card {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 0;
            border: 1px solid rgba(96, 165, 250, 0.1);
            transition: all 0.3s ease;
        }

        .glass-card:hover {
            box-shadow: 0 5px 15px rgba(15, 23, 42, 0.5);
            transform: translateY(-2px);
        }

        .parallax-section {
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Input fields & button overrides */
        input, textarea {
            background-color: rgba(15, 23, 42, 0.8) !important;
            color: #e2e8f0 !important;
            border-color: #475569 !important;
        }
        
        input::placeholder, textarea::placeholder {
            color: #94a3b8 !important;
            opacity: 0.7;
        }
        
        input:focus, textarea:focus {
            outline-color: #3b82f6 !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <div id="password-form" class="max-w-md mx-auto p-8 rounded-lg">
        <div class="glass-card p-8 rounded-lg">
            <h2 class="text-3xl font-bold mb-6 text-center text-blue-100">Stormy Reflections</h2>
            <p class="mb-4 text-center text-slate-300">Enter the password to access this personal journal</p>
            <div class="space-y-4 w-full">
                <input type="password" id="password-input" class="w-full px-4 py-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter password">
                <button id="submit-btn" class="w-full ocean-gradient hover:opacity-90 text-white font-semibold py-2 px-4 transition-colors">Enter</button>
            </div>
            <p id="error-message" class="text-red-500 mt-4 text-center hidden">Incorrect password. Please try again.</p>
        </div>
    </div>

    <div id="content">
        <header class="py-16 relative">
            <div class="max-w-5xl mx-auto px-6">
                <div class="header-content">
                    <div class="flex justify-between items-center mb-4">
                        <h1 class="text-4xl md:text-5xl font-bold text-blue-100 animate-header">Stormy Reflections</h1>
                        <a href="index.html" class="text-blue-400 hover:text-blue-300 font-semibold">‚Üê Home</a>
                    </div>
                    <p class="text-xl text-slate-300 italic">Thoughts amidst the tempest of life</p>
                </div>
            </div>
        </header>
        
        <main class="max-w-3xl mx-auto py-12 px-6 relative z-10">
            <!-- Blog Controls -->
            <div class="flex justify-between items-center mb-8">
                <h2 class="text-2xl font-bold">My Thoughts</h2>
                <button id="new-post-btn" class="ocean-gradient text-white px-4 py-2 hover:opacity-90 transition-opacity">
                    New Entry
                </button>
            </div>

            <!-- New Post Form -->
            <div id="post-form" class="mb-12 glass-card p-6 rounded-lg hidden">
                <div class="mb-4">
                    <label for="post-title" class="block mb-2 font-semibold">Title</label>
                    <input type="text" id="post-title" class="w-full px-4 py-2 border focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="mb-4">
                    <label for="post-content" class="block mb-2 font-semibold">Content</label>
                    <textarea id="post-content" rows="8" class="w-full px-4 py-2 border focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                </div>
                <div class="flex space-x-2 justify-end">
                    <button id="cancel-post" class="px-4 py-2 border hover:bg-slate-800 text-slate-300 border-slate-600 transition-colors">Cancel</button>
                    <button id="save-post" class="ocean-gradient text-white px-4 py-2 hover:opacity-90 transition-opacity">Save</button>
                </div>
                <input type="hidden" id="post-id" value="">
            </div>

            <!-- Post container -->
            <div id="posts-container" class="space-y-8">
                <!-- Blog posts will be loaded here dynamically -->
                <div class="text-center py-12" id="loading-posts">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-slate-400">Loading your thoughts...</p>
                </div>
                <div class="hidden text-center py-12" id="no-posts">
                    <p class="text-slate-400">No thoughts yet. Click "New Entry" to add one.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Three.js Stormy Ocean Animation
        let scene, camera, renderer;
        let ocean, oceanGeometry, oceanMaterial;
        let sky, skyMaterial;
        let lightning = false;
        let lightningTime = 0;
        let clock = new THREE.Clock();
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f172a, 0.01);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 50);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('three-canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0f172a, 1);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x334155, 0.2);
            scene.add(ambientLight);
            
            // Moonlight
            const moonLight = new THREE.DirectionalLight(0x94a3b8, 0.4);
            moonLight.position.set(-50, 40, -50);
            scene.add(moonLight);
            
            // Create stormy sky
            createStormySky();
            
            // Create turbulent ocean
            createOcean();
            
            // Event listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
        }
        
        function createStormySky() {
            // Create sky
            const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
            
            // Create sky gradient
            const uniforms = {
                topColor: { value: new THREE.Color(0x0f172a) },      // Very dark blue at top
                bottomColor: { value: new THREE.Color(0x1e3a8a) },   // Deep navy at horizon
                offset: { value: 20 },
                exponent: { value: 0.4 }
            };
            
            skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(h, exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Add some clouds (simple dark planes at different heights)
            const cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0x1e293b,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 20; i++) {
                const cloudSize = 30 + Math.random() * 100;
                const cloudGeometry = new THREE.PlaneGeometry(cloudSize, cloudSize);
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                // Position the cloud randomly
                cloud.position.set(
                    (Math.random() - 0.5) * 300,
                    60 + Math.random() * 40,
                    (Math.random() - 0.5) * 300
                );
                
                // Rotate the cloud
                cloud.rotation.x = Math.PI / 2;
                cloud.rotation.z = Math.random() * Math.PI;
                
                scene.add(cloud);
            }
        }
        
        function createOcean() {
            // Create a large plane for the ocean
            oceanGeometry = new THREE.PlaneGeometry(400, 400, 100, 100);
            
            // Ocean material with vertex displacement
            oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x1e3a8a,
                specular: 0x111827,
                shininess: 10
            });
            
            ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.y = -5;
            scene.add(ocean);
            
            // Add a distant boat silhouette
            const boatGeometry = new THREE.BoxGeometry(8, 4, 20);
            const boatMaterial = new THREE.MeshBasicMaterial({ color: 0x0f172a });
            const boat = new THREE.Mesh(boatGeometry, boatMaterial);
            boat.position.set(0, 0, -50);
            scene.add(boat);
            
            // Add mast
            const mastGeometry = new THREE.CylinderGeometry(0.5, 0.5, 15);
            const mast = new THREE.Mesh(mastGeometry, boatMaterial);
            mast.position.set(0, 7.5, -50);
            scene.add(mast);
        }
        
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - windowHalfX) * 0.01;
            mouseY = (event.clientY - windowHalfY) * 0.01;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // Animate ocean waves
            if (oceanGeometry && oceanGeometry.attributes.position) {
                const positions = oceanGeometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const z = positions.getZ(i);
                    
                    // Create turbulent waves
                    const waveHeight1 = Math.sin(time * 0.8 + x * 0.05) * 2;
                    const waveHeight2 = Math.cos(time * 1.2 + z * 0.04) * 2;
                    const waveHeight3 = Math.sin(time * 0.7 + x * 0.02 + z * 0.03) * 1.5;
                    
                    // Combine waves for more turbulent effect
                    const finalHeight = waveHeight1 + waveHeight2 + waveHeight3;
                    
                    positions.setY(i, finalHeight);
                }
                
                positions.needsUpdate = true;
                oceanGeometry.computeVertexNormals();
            }
            
            // Occasional lightning
            if (Math.random() < 0.005 && !lightning) {
                lightning = true;
                lightningTime = time;
                
                // Add bright directional light
                const lightningLight = new THREE.DirectionalLight(0xffffff, 1.5);
                lightningLight.position.set(Math.random() * 100 - 50, 60, Math.random() * 100 - 50);
                lightningLight.name = 'lightning';
                scene.add(lightningLight);
            }
            
            // Turn off lightning after a short time
            if (lightning && time - lightningTime > 0.2) {
                lightning = false;
                
                // Remove lightning light
                const lightningLight = scene.getObjectByName('lightning');
                if (lightningLight) {
                    scene.remove(lightningLight);
                }
            }
            
            // Move camera slightly based on mouse
            camera.position.x += (mouseX - camera.position.x) * 0.01;
            camera.position.y += (mouseY + 10 - camera.position.y) * 0.01;
            camera.lookAt(0, 0, -30);
            
            renderer.render(scene, camera);
        }

        // Parallax effect for blog posts
        function handleParallax() {
            const parallaxElements = document.querySelectorAll('.parallax-section');
            
            window.addEventListener('scroll', function() {
                const scrollY = window.scrollY;
                
                parallaxElements.forEach(element => {
                    const speed = parseFloat(element.getAttribute('data-speed'));
                    const yOffset = scrollY * speed;
                    element.style.transform = `translateY(${yOffset}px)`;
                });
            });
        }
        
        // Blog Database Management
        class BlogDB {
            constructor() {
                this.dbName = 'sunlitThoughtsDB';
                this.dbVersion = 1;
                this.storeName = 'posts';
                this.db = null;
                this.init();
            }
            
            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = event => {
                        console.error('Database error:', event.target.error);
                        reject('Could not open database');
                    };
                    
                    request.onsuccess = event => {
                        this.db = event.target.result;
                        console.log('Database opened successfully');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = event => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                            store.createIndex('title', 'title', { unique: false });
                            store.createIndex('date', 'date', { unique: false });
                            console.log('Object store created');
                        }
                    };
                });
            }
            
            async getAllPosts() {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        resolve(request.result.sort((a, b) => new Date(b.date) - new Date(a.date)));
                    };
                    
                    request.onerror = event => {
                        console.error('Error fetching posts:', event.target.error);
                        reject('Failed to fetch posts');
                    };
                });
            }
            
            async addPost(post) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.add(post);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error adding post:', event.target.error);
                        reject('Failed to add post');
                    };
                });
            }
            
            async updatePost(post) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.put(post);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error updating post:', event.target.error);
                        reject('Failed to update post');
                    };
                });
            }
            
            async deletePost(id) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(id);
                    
                    request.onsuccess = () => {
                        resolve();
                    };
                    
                    request.onerror = event => {
                        console.error('Error deleting post:', event.target.error);
                        reject('Failed to delete post');
                    };
                });
            }
            
            async getPost(id) {
                await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(id);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = event => {
                        console.error('Error fetching post:', event.target.error);
                        reject('Failed to fetch post');
                    };
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Three.js
            init();
            
            // Database instance
            const blogDB = new BlogDB();
            
            // UI Elements
            const submitBtn = document.getElementById('submit-btn');
            const passwordInput = document.getElementById('password-input');
            const passwordForm = document.getElementById('password-form');
            const content = document.getElementById('content');
            const errorMessage = document.getElementById('error-message');
            const newPostBtn = document.getElementById('new-post-btn');
            const postForm = document.getElementById('post-form');
            const postsContainer = document.getElementById('posts-container');
            const loadingElement = document.getElementById('loading-posts');
            const noPostsElement = document.getElementById('no-posts');
            const postTitleInput = document.getElementById('post-title');
            const postContentInput = document.getElementById('post-content');
            const postIdInput = document.getElementById('post-id');
            const savePostBtn = document.getElementById('save-post');
            const cancelPostBtn = document.getElementById('cancel-post');
            
            // The password to access the content
            const correctPassword = "08151769";
            
            // Check if already authenticated
            const isAuthenticated = sessionStorage.getItem('privateAuth');
            if (isAuthenticated === 'true') {
                showContent();
            }
            
            // Event Listeners
            submitBtn.addEventListener('click', validatePassword);
            passwordInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') {
                    validatePassword();
                }
            });
            
            newPostBtn.addEventListener('click', () => {
                resetForm();
                postForm.classList.remove('hidden');
            });
            
            cancelPostBtn.addEventListener('click', () => {
                postForm.classList.add('hidden');
            });
            
            savePostBtn.addEventListener('click', handleSavePost);
            
            // Functions
            function validatePassword() {
                if (passwordInput.value === correctPassword) {
                    sessionStorage.setItem('privateAuth', 'true');
                    showContent();
                } else {
                    errorMessage.classList.remove('hidden');
                    passwordInput.value = '';
                }
            }
            
            function showContent() {
                passwordForm.style.display = 'none';
                content.style.display = 'block';
                
                // Initialize parallax after content is shown
                handleParallax();
                
                // Load blog posts
                loadPosts();
                
                // Animation for header
                gsap.from('.animate-header', {
                    opacity: 0,
                    y: 30,
                    duration: 1,
                    ease: "power2.out"
                });
            }
            
            async function loadPosts() {
                try {
                    const posts = await blogDB.getAllPosts();
                    displayPosts(posts);
                } catch (error) {
                    console.error('Error loading posts:', error);
                    alert('Failed to load posts. Please try again.');
                } finally {
                    loadingElement.classList.add('hidden');
                }
            }
            
            function displayPosts(posts) {
                // Clear previous posts
                const postsOnly = Array.from(postsContainer.children).filter(child => 
                    child.id !== 'loading-posts' && child.id !== 'no-posts'
                );
                postsOnly.forEach(post => post.remove());
                
                if (posts.length === 0) {
                    noPostsElement.classList.remove('hidden');
                    return;
                }
                
                noPostsElement.classList.add('hidden');
                
                // Create and append posts
                posts.forEach((post, index) => {
                    const postElement = createPostElement(post, index);
                    postsContainer.appendChild(postElement);
                });
                
                // Apply parallax to new elements
                handleParallax();
                
                // Animate posts
                gsap.from('.blog-post', {
                    opacity: 0,
                    y: 50,
                    stagger: 0.2,
                    duration: 0.8,
                    ease: "back.out(1.7)"
                });
            }
            
            function createPostElement(post, index) {
                const article = document.createElement('article');
                article.className = `blog-post pl-6 pt-2 pb-6 rounded-lg elegant-shadow parallax-section`;
                article.dataset.speed = 0.03 + (index * 0.02);
                article.dataset.id = post.id;
                
                const formattedDate = new Date(post.date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                article.innerHTML = `
                    <div class="flex justify-between items-start">
                        <p class="date text-sm mb-3">${formattedDate}</p>
                        <div class="flex space-x-2">
                            <button class="edit-post-btn text-blue-300 hover:text-blue-100">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                </svg>
                            </button>
                            <button class="delete-post-btn text-red-400 hover:text-red-300">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <h2 class="text-2xl font-bold mb-4 text-blue-100">${post.title}</h2>
                    <div class="prose prose-invert prose-slate">
                        <p class="mb-4 text-slate-300">${post.content.replace(/\n/g, '<br>')}</p>
                    </div>
                `;
                
                // Add event listeners
                article.querySelector('.edit-post-btn').addEventListener('click', () => {
                    editPost(post.id);
                });
                
                article.querySelector('.delete-post-btn').addEventListener('click', () => {
                    deletePost(post.id);
                });
                
                return article;
            }
            
            async function handleSavePost() {
                const title = postTitleInput.value.trim();
                const content = postContentInput.value.trim();
                const id = postIdInput.value ? parseInt(postIdInput.value) : null;
                
                if (!title || !content) {
                    alert('Please fill in both title and content');
                    return;
                }
                
                try {
                    if (id) {
                        // Update existing post
                        const post = await blogDB.getPost(id);
                        post.title = title;
                        post.content = content;
                        post.updated = new Date().toISOString();
                        await blogDB.updatePost(post);
                    } else {
                        // Add new post
                        const post = {
                            title,
                            content,
                            date: new Date().toISOString(),
                            updated: null
                        };
                        await blogDB.addPost(post);
                    }
                    
                    postForm.classList.add('hidden');
                    resetForm();
                    loadPosts();
                } catch (error) {
                    console.error('Error saving post:', error);
                    alert('Failed to save post. Please try again.');
                }
            }
            
            async function editPost(id) {
                try {
                    const post = await blogDB.getPost(id);
                    postTitleInput.value = post.title;
                    postContentInput.value = post.content;
                    postIdInput.value = post.id;
                    postForm.classList.remove('hidden');
                    postForm.scrollIntoView({ behavior: 'smooth' });
                } catch (error) {
                    console.error('Error editing post:', error);
                    alert('Failed to edit post. Please try again.');
                }
            }
            
            async function deletePost(id) {
                if (!confirm('Are you sure you want to delete this post?')) {
                    return;
                }
                
                try {
                    await blogDB.deletePost(id);
                    loadPosts();
                } catch (error) {
                    console.error('Error deleting post:', error);
                    alert('Failed to delete post. Please try again.');
                }
            }
            
            function resetForm() {
                postTitleInput.value = '';
                postContentInput.value = '';
                postIdInput.value = '';
            }
        });
    </script>
</body>
</html>